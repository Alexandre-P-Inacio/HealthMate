// Health Connect Service - Implementa√ß√£o Correta com Plugin Oficial Expo
// Plugin: expo-health-connect (configura√ß√£o)
// C√≥digo: react-native-health-connect (runtime)

import { Platform } from 'react-native';
import {
  initialize,
  requestPermission,
  getSdkStatus,
  readRecords,
  openHealthConnectSettings,
  SdkAvailabilityStatus
} from 'react-native-health-connect';

class HealthConnectService {
  constructor() {
    this.isInitialized = false;
    this.hasPermissions = false;
  }

  /**
   * Verifica se Health Connect est√° dispon√≠vel
   */
  async checkAvailability() {
    try {
      if (Platform.OS !== 'android') {
        return {
          isAvailable: false,
          message: 'Health Connect est√° dispon√≠vel apenas no Android'
        };
      }

      const status = await getSdkStatus();
      console.log('üìä Health Connect SDK Status:', status);

      switch (status) {
        case SdkAvailabilityStatus.SDK_AVAILABLE:
          return {
            isAvailable: true,
            status: status,
            message: 'Health Connect dispon√≠vel'
          };
        case SdkAvailabilityStatus.SDK_UNAVAILABLE:
          return {
            isAvailable: false,
            status: status,
            message: 'Health Connect n√£o est√° dispon√≠vel neste dispositivo'
          };
        case SdkAvailabilityStatus.SDK_UNAVAILABLE_PROVIDER_UPDATE_REQUIRED:
          return {
            isAvailable: false,
            status: status,
            message: 'Health Connect precisa ser atualizado via Google Play Store'
          };
        default:
          return {
            isAvailable: true,
            status: status,
            message: 'Health Connect instalado mas precisa de configura√ß√£o'
          };
      }
    } catch (error) {
      console.error('‚ùå Erro ao verificar Health Connect:', error);
      return {
        isAvailable: false,
        message: `Erro: ${error.message}`
      };
    }
  }

  /**
   * Inicializa Health Connect corretamente
   */
  async initializeHealthConnect() {
    try {
      console.log('üîÑ Inicializando Health Connect...');

      // Se j√° foi inicializado, retorna sucesso
      if (this.isInitialized) {
        return {
          success: true,
          message: 'Health Connect j√° inicializado',
          status: 'INITIALIZED'
        };
      }

      // Verifica disponibilidade primeiro
      const availability = await this.checkAvailability();
      if (!availability.isAvailable) {
        return {
          success: false,
          message: availability.message
        };
      }

      // Inicializa a biblioteca com retry
      let initialized = false;
      let attempts = 0;
      const maxAttempts = 3;

      while (!initialized && attempts < maxAttempts) {
        try {
          attempts++;
          console.log(`üîÑ Tentativa ${attempts} de inicializa√ß√£o...`);
          
          initialized = await initialize();
          
          if (initialized) {
            // Aguarda um momento para garantir que a inicializa√ß√£o foi completada
            await new Promise(resolve => setTimeout(resolve, 1000));
            break;
          } else {
            console.log(`‚ö†Ô∏è Tentativa ${attempts} falhou, tentando novamente...`);
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        } catch (error) {
          console.log(`‚ö†Ô∏è Erro na tentativa ${attempts}:`, error.message);
          if (attempts === maxAttempts) {
            throw error;
          }
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }

      if (!initialized) {
        throw new Error('Falha ao inicializar Health Connect ap√≥s m√∫ltiplas tentativas');
      }

      this.isInitialized = true;
      console.log('‚úÖ Health Connect inicializado com sucesso');

      return {
        success: true,
        message: 'Health Connect inicializado',
        status: availability.status
      };

    } catch (error) {
      console.error('‚ùå Erro na inicializa√ß√£o:', error);
      this.isInitialized = false;
      
      return {
        success: false,
        message: `Falha na inicializa√ß√£o: ${error.message}`
      };
    }
  }

  /**
   * Solicita permiss√µes necess√°rias
   */
  async requestHealthPermissions() {
    try {
      // SEMPRE inicializa primeiro para evitar o erro lateinit
      const initResult = await this.initializeHealthConnect();
      if (!initResult.success) {
        return {
          success: false,
          message: initResult.message,
          needsSettings: true
        };
      }

      // Aguarda um momento para garantir que a inicializa√ß√£o foi completada
      await new Promise(resolve => setTimeout(resolve, 500));

      console.log('üîê Solicitando permiss√µes do Health Connect...');

      // Define as permiss√µes necess√°rias - VERS√ÉO MELHORADA
      const permissions = [
        { accessType: 'read', recordType: 'Weight' },
        { accessType: 'read', recordType: 'HeartRate' },
        { accessType: 'read', recordType: 'Steps' },
        { accessType: 'read', recordType: 'Distance' },
        { accessType: 'read', recordType: 'ActiveCaloriesBurned' },
        { accessType: 'read', recordType: 'BloodPressure' },
        { accessType: 'read', recordType: 'OxygenSaturation' },
        { accessType: 'read', recordType: 'BodyTemperature' },
        { accessType: 'read', recordType: 'SleepSession' }
      ];

      // FOR√áA a solicita√ß√£o de permiss√µes para que o app apare√ßa na lista
      console.log('üéØ For√ßando apari√ß√£o do app na lista de permiss√µes...');
      
      // Primeiro tenta solicitar UMA permiss√£o para for√ßar a apari√ß√£o na lista
      try {
        const basicPermission = [{ accessType: 'read', recordType: 'Weight' }];
        console.log('üìù Solicitando permiss√£o b√°sica primeiro...');
        await requestPermission(basicPermission);
      } catch (basicError) {
        console.log('‚ö†Ô∏è Erro na permiss√£o b√°sica (normal):', basicError.message);
      }

      // Aguarda um momento
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Agora solicita TODAS as permiss√µes
      console.log('üìã Solicitando todas as permiss√µes...');
      const grantedPermissions = await requestPermission(permissions);
      console.log('üìã Permiss√µes concedidas:', grantedPermissions);

      this.hasPermissions = grantedPermissions && grantedPermissions.length > 0;

      if (this.hasPermissions) {
        return {
          success: true,
          message: `${grantedPermissions.length} permiss√µes concedidas`,
          permissions: grantedPermissions
        };
      } else {
        // Se n√£o conseguiu permiss√µes, abre as configura√ß√µes automaticamente
        console.log('üîß Abrindo configura√ß√µes do Health Connect...');
        await this.openSettings();
        
        return {
          success: false,
          message: 'Nenhuma permiss√£o foi concedida. Configura√ß√µes abertas - conceda as permiss√µes manualmente.',
          needsSettings: true,
          settingsOpened: true
        };
      }

    } catch (error) {
      console.error('‚ùå Erro ao solicitar permiss√µes:', error);
      
      // Se for o erro lateinit, retorna mensagem espec√≠fica
      if (error.message.includes('lateinit') || error.message.includes('requestPermission')) {
        return {
          success: false,
          message: 'Erro de inicializa√ß√£o do Health Connect. Reinicie o app e tente novamente.',
          needsSettings: true
        };
      }
      
      // Para outros erros, abre as configura√ß√µes
      try {
        console.log('üîß Erro nas permiss√µes - abrindo configura√ß√µes...');
        await this.openSettings();
      } catch (settingsError) {
        console.log('‚ö†Ô∏è Erro ao abrir configura√ß√µes:', settingsError.message);
      }
      
      return {
        success: false,
        message: error.message + ' - Configura√ß√µes abertas para configura√ß√£o manual.',
        needsSettings: true,
        settingsOpened: true
      };
    }
  }

  /**
   * Busca dados de peso de QUALQUER app no Health Connect
   */
  async getWeightData(daysBack = 7) {
    try {
      // SEMPRE inicializa primeiro para evitar erros
      const initResult = await this.initializeHealthConnect();
      if (!initResult.success) {
        return {
          success: false,
          error: initResult.message,
          needsPermissions: true
        };
      }

      // Aguarda para garantir inicializa√ß√£o completa
      await new Promise(resolve => setTimeout(resolve, 300));

      // Verifica/solicita permiss√µes
      if (!this.hasPermissions) {
        const permResult = await this.requestHealthPermissions();
        if (!permResult.success) {
          return {
            success: false,
            error: permResult.message,
            needsPermissions: true
          };
        }
      }

      console.log('üîç Buscando dados de PESO de todos os apps...');

      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(endDate.getDate() - daysBack);

      // Busca dados de PESO de QUALQUER app
      const records = await readRecords('Weight', {
        timeRangeFilter: {
          operator: 'between',
          startTime: startDate.toISOString(),
          endTime: endDate.toISOString(),
        },
        // SEM filtro de dataOrigin - pega de TODOS os apps
      });

      if (records && records.length > 0) {
        const weightData = records.map(record => ({
          weight: record.weight.inKilograms,
          timestamp: record.time,
          source: this.getSourceName(record.metadata?.dataOrigin?.packageName || 'Unknown')
        }));

        // Ordena por data (mais recente primeiro)
        weightData.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        console.log(`‚úÖ ${weightData.length} registros de PESO encontrados de v√°rios apps`);

        return {
          success: true,
          data: weightData,
          latest: weightData[0],
          count: weightData.length,
          category: 'Peso'
        };
      } else {
        console.log('üìä Nenhum registro de PESO encontrado em nenhum app');
        return {
          success: true,
          data: [],
          message: 'Nenhum dado de peso encontrado em nenhum app conectado ao Health Connect',
          category: 'Peso'
        };
      }

    } catch (error) {
      console.error('‚ùå Erro ao buscar dados de PESO:', error);
      
      // Trata erros espec√≠ficos
      if (error.message.includes('lateinit') || error.message.includes('permission')) {
        return {
          success: false,
          error: 'Erro de inicializa√ß√£o. Reinicie o app e tente novamente.',
          needsPermissions: true
        };
      }
      
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Busca dados de sa√∫de por CATEGORIA de QUALQUER app
   */
  async getHealthDataByCategory(daysBack = 7) {
    try {
      // SEMPRE inicializa primeiro para evitar erros
      const initResult = await this.initializeHealthConnect();
      if (!initResult.success) {
        return {
          success: false,
          error: initResult.message,
          needsPermissions: true
        };
      }

      // Aguarda para garantir inicializa√ß√£o completa
      await new Promise(resolve => setTimeout(resolve, 300));

      // Verifica/solicita permiss√µes
      if (!this.hasPermissions) {
        const permResult = await this.requestHealthPermissions();
        if (!permResult.success) {
          return {
            success: false,
            error: permResult.message,
            needsPermissions: true
          };
        }
      }

      console.log('üì± Buscando dados de SA√öDE por categoria de todos os apps...');

      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(endDate.getDate() - daysBack);

      const timeRangeFilter = {
        operator: 'between',
        startTime: startDate.toISOString(),
        endTime: endDate.toISOString(),
      };

      // Busca CADA CATEGORIA de dados de QUALQUER app
      const [
        heartRateRecords,
        stepsRecords, 
        caloriesRecords,
        distanceRecords,
        bloodPressureRecords,
        oxygenRecords,
        temperatureRecords,
        sleepRecords
      ] = await Promise.all([
        this.safeReadRecords('HeartRate', timeRangeFilter),
        this.safeReadRecords('Steps', timeRangeFilter),
        this.safeReadRecords('ActiveCaloriesBurned', timeRangeFilter),
        this.safeReadRecords('Distance', timeRangeFilter),
        this.safeReadRecords('BloodPressure', timeRangeFilter),
        this.safeReadRecords('OxygenSaturation', timeRangeFilter),
        this.safeReadRecords('BodyTemperature', timeRangeFilter),
        this.safeReadRecords('SleepSession', timeRangeFilter)
      ]);

      // Processa os dados por CATEGORIA
      const healthData = {
        heartRate: this.getLatestHeartRate(heartRateRecords),
        steps: this.getTotalSteps(stepsRecords),
        calories: this.getTotalCalories(caloriesRecords),
        distance: this.getTotalDistance(distanceRecords),
        bloodPressure: this.getLatestBloodPressure(bloodPressureRecords),
        bloodOxygen: this.getLatestOxygen(oxygenRecords),
        bodyTemperature: this.getLatestTemperature(temperatureRecords),
        sleepData: this.getLatestSleep(sleepRecords),
        timestamp: new Date().toISOString()
      };

      const availableCategories = Object.keys(healthData)
        .filter(key => key !== 'timestamp')
        .filter(key => healthData[key] !== null && healthData[key] !== undefined);

      console.log(`‚úÖ Dados de sa√∫de: ${availableCategories.length} CATEGORIAS dispon√≠veis`);

      return {
        success: true,
        data: healthData,
        availableCategories: availableCategories,
        summary: this.createCategorySummary(healthData),
        categories: this.getCategoryDetails(healthData)
      };

    } catch (error) {
      console.error('‚ùå Erro ao buscar dados de sa√∫de por categoria:', error);
      
      // Trata erros espec√≠ficos
      if (error.message.includes('lateinit') || error.message.includes('permission')) {
        return {
          success: false,
          error: 'Erro de inicializa√ß√£o. Reinicie o app e tente novamente.',
          needsPermissions: true
        };
      }
      
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * L√™ registros de forma segura
   */
  async safeReadRecords(recordType, timeRangeFilter) {
    try {
      const records = await readRecords(recordType, { timeRangeFilter });
      console.log(`üìä ${recordType}: ${records.length} registros`);
      return records || [];
    } catch (error) {
      console.log(`‚ö†Ô∏è Erro ao ler ${recordType}: ${error.message}`);
      return [];
    }
  }

  /**
   * Processa frequ√™ncia card√≠aca
   */
  getLatestHeartRate(records) {
    if (!records || records.length === 0) return null;
    const sorted = records.sort((a, b) => new Date(b.time) - new Date(a.time));
    return sorted[0].beatsPerMinute;
  }

  /**
   * Processa passos
   */
  getTotalSteps(records) {
    if (!records || records.length === 0) return null;
    return records.reduce((total, record) => total + (record.count || 0), 0);
  }

  /**
   * Processa calorias
   */
  getTotalCalories(records) {
    if (!records || records.length === 0) return null;
    return records.reduce((total, record) => total + (record.energy?.inCalories || 0), 0);
  }

  /**
   * Processa dist√¢ncia
   */
  getTotalDistance(records) {
    if (!records || records.length === 0) return null;
    const totalMeters = records.reduce((total, record) => total + (record.distance?.inMeters || 0), 0);
    return (totalMeters / 1000).toFixed(2); // Converte para km
  }

  /**
   * Processa press√£o arterial
   */
  getLatestBloodPressure(records) {
    if (!records || records.length === 0) return null;
    const sorted = records.sort((a, b) => new Date(b.time) - new Date(a.time));
    const latest = sorted[0];
    return {
      systolic: latest.systolic?.inMillimetersOfMercury,
      diastolic: latest.diastolic?.inMillimetersOfMercury,
      timestamp: latest.time
    };
  }

  /**
   * Processa oxigena√ß√£o do sangue
   */
  getLatestOxygen(records) {
    if (!records || records.length === 0) return null;
    const sorted = records.sort((a, b) => new Date(b.time) - new Date(a.time));
    return sorted[0].percentage?.value;
  }

  /**
   * Processa temperatura corporal
   */
  getLatestTemperature(records) {
    if (!records || records.length === 0) return null;
    const sorted = records.sort((a, b) => new Date(b.time) - new Date(a.time));
    return sorted[0].temperature?.inCelsius;
  }

  /**
   * Processa dados de sono
   */
  getLatestSleep(records) {
    if (!records || records.length === 0) return null;
    const sorted = records.sort((a, b) => new Date(b.startTime) - new Date(a.startTime));
    const latest = sorted[0];
    const duration = (new Date(latest.endTime) - new Date(latest.startTime)) / (1000 * 60 * 60); // horas
    return {
      duration: duration.toFixed(1),
      startTime: latest.startTime,
      endTime: latest.endTime
    };
  }

  /**
   * Cria resumo por categorias
   */
  createCategorySummary(healthData) {
    const summary = [];
    if (healthData.heartRate) summary.push(`‚ù§Ô∏è Freq. Card√≠aca: ${healthData.heartRate} bpm`);
    if (healthData.steps) summary.push(`üö∂ Passos: ${healthData.steps.toLocaleString()}`);
    if (healthData.calories) summary.push(`üî• Calorias: ${Math.round(healthData.calories)} kcal`);
    if (healthData.distance) summary.push(`üìè Dist√¢ncia: ${healthData.distance} km`);
    if (healthData.bloodPressure) summary.push(`ü©∏ Press√£o: ${healthData.bloodPressure.systolic}/${healthData.bloodPressure.diastolic} mmHg`);
    if (healthData.bloodOxygen) summary.push(`üí® SpO2: ${healthData.bloodOxygen}%`);
    if (healthData.bodyTemperature) summary.push(`üå°Ô∏è Temperatura: ${healthData.bodyTemperature}¬∞C`);
    if (healthData.sleepData) summary.push(`üò¥ Sono: ${healthData.sleepData.duration}h`);
    return summary.join('\n');
  }

  /**
   * Obt√©m detalhes das categorias
   */
  getCategoryDetails(healthData) {
    const categories = [];
    if (healthData.heartRate) categories.push({ name: 'Frequ√™ncia Card√≠aca', value: healthData.heartRate, unit: 'bpm', icon: '‚ù§Ô∏è' });
    if (healthData.steps) categories.push({ name: 'Passos', value: healthData.steps.toLocaleString(), unit: 'passos', icon: 'üö∂' });
    if (healthData.calories) categories.push({ name: 'Calorias', value: Math.round(healthData.calories), unit: 'kcal', icon: 'üî•' });
    if (healthData.distance) categories.push({ name: 'Dist√¢ncia', value: healthData.distance, unit: 'km', icon: 'üìè' });
    if (healthData.bloodPressure) categories.push({ name: 'Press√£o Arterial', value: `${healthData.bloodPressure.systolic}/${healthData.bloodPressure.diastolic}`, unit: 'mmHg', icon: 'ü©∏' });
    if (healthData.bloodOxygen) categories.push({ name: 'Oxigena√ß√£o', value: healthData.bloodOxygen, unit: '%', icon: 'üí®' });
    if (healthData.bodyTemperature) categories.push({ name: 'Temperatura', value: healthData.bodyTemperature, unit: '¬∞C', icon: 'üå°Ô∏è' });
    if (healthData.sleepData) categories.push({ name: 'Sono', value: healthData.sleepData.duration, unit: 'horas', icon: 'üò¥' });
    return categories;
  }

  /**
   * Mapeia nomes de apps
   */
  getSourceName(packageName) {
    const sourceNames = {
      'com.sec.android.app.shealth': 'Samsung Health',
      'com.google.android.apps.fitness': 'Google Fit', 
      'com.fitdays.fitdays': 'FitDays',
      'com.mi.health': 'Mi Health',
      'com.huawei.health': 'Huawei Health',
      'com.fitbit.FitbitMobile': 'Fitbit',
      'com.garmin.android.apps.connectmobile': 'Garmin Connect',
      'com.polar.polarflow': 'Polar Flow'
    };
    return sourceNames[packageName] || packageName || 'Health Connect';
  }

  /**
   * Abre configura√ß√µes do Health Connect
   */
  async openSettings() {
    try {
      await openHealthConnectSettings();
      return true;
    } catch (error) {
      console.error('‚ùå Erro ao abrir configura√ß√µes:', error);
      return false;
    }
  }
}

export default new HealthConnectService(); 